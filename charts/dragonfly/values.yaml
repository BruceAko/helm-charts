nameOverride: ""
namespaceOverride: "dragonfly-system"
fullnameOverride: ""

# values for dragonfly installation
installation:
  clusterDomain: ""
  # enable an all in one jaeger for tracing every downloading event
  # should not use in production environment
  jaeger: false

scheduler:
  name: scheduler
  nameOverride: ""
  fullnameOverride: ""
  replicas: 3
  image: dragonflyoss/scheduler
  tag: v0.1.0
  pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: "0"
      memory: "0"
    limits:
      cpu: "4"
      memory: "8Gi"
  priorityClassName: ""
  nodeSelector: {}
  terminationGracePeriodSeconds:
  tolerations: []
  podAnnotations: {}
  podLabels: {}
  serviceAnnotations: {}
  statefulsetAnnotations: {}
  containerPort: 8002
  service:
    type: ClusterIP
    port: 8002
    targetPort: 8002
  config:
    debug: false
    worker:
      workerNum: 4
      workerJobPoolSize: 10000
      senderNum: 10
      senderJobPoolSize: 10000
    dynconfig:
      type: manager
    manager:
      schedulerClusterID: 0
      keepAlive:
        interval: 5s
        retryMaxAttempts: 100000000
        retryInitBackOff: 5
        retryMaxBackOff: 10

cdn:
  name: cdn
  nameOverride: ""
  fullnameOverride: ""
  replicas: 3
  image: dragonflyoss/cdn
  tag: v0.1.0
  pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: "0"
      memory: "0"
    limits:
      cpu: "4"
      memory: "8Gi"
  priorityClassName: ""
  nodeSelector: {}
  terminationGracePeriodSeconds:
  tolerations: []
  podAnnotations: {}
  podLabels: {}
  statefulsetAnnotations: {}
  containerPort: 8003
  nginxContiainerPort: 8001
  service:
    type: ClusterIP
    port: 8003
    targetPort: 8003
    extraPorts:
      - name: http-nginx
        port: 8001
        targetPort: 8001
  config:
    base:
      systemReservedBandwidth: 20M
      maxBandwidth: 200M
      enableProfiler: false
      failAccessInterval: 3m
      gcInitialDelay: 6s
      gcMetaInterval: 2m
      gcStorageInterval: 15s
      taskExpireTime: 3m
      storagePattern: disk
      manager:
        cdnClusterID: 0
        keepAlive:
          interval: 5s
          retryMaxAttempts: 100000000
          retryInitBackOff: 5
          retryMaxBackOff: 10
      console: false
    plugins:
      storageDriver:
        - name: disk
          enable: true
          config:
            baseDir: /tmp/cdn
      storageManager:
        - name: disk
          enable: true
          config:
            gcInitialDelay: 5s
            gcInterval: 15s
            driverConfigs:
              disk:
                gcConfig:
                  youngGCThreshold: 100G
                  fullGCThreshold: 5G
                  cleanRatio: 1
                  intervalThreshold: 2h

dfdaemon:
  name: dfdaemon
  nameOverride: ""
  fullnameOverride: ""
  image: dragonflyoss/dfdaemon
  tag: v0.1.0
  pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: "0"
      memory: "0"
    limits:
      cpu: "2"
      memory: "2Gi"
  priorityClassName: ""
  nodeSelector: {}
  terminationGracePeriodSeconds:
  tolerations: []
  podAnnotations: {}
  podLabels: {}
  daemonsetAnnotations: {}
  containerPort: 65001
  # hostPort is used when .hostNetwork == false, and .config.proxy.tcpListen.namespace is empty
  # many network add-ons do not yet support hostPort
  # https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#hostport-services-do-not-work
  # by default, dfdaemon injects the 65001 port to host network by sharing host network namespace,
  # if you want to use hostPort, please empty .config.proxy.tcpListen.namespace below, and keep .hostNetwork == false
  # for performance, injecting the 65001 port to host network is better than hostPort
  hostPort: 65001
  # using hostNetwork when pod with host network can communicate with normal pods with cni network
  hostNetwork: false
  config:
    aliveTime: 0s
    gcInterval: 1m0s
    keepStorage: false
    verbose: true
    jaeger: "" # customize jaeger like: http://localhost:14268/api/traces
    host:
      listenIP: 0.0.0.0
      advertiseIP: 0.0.0.0
    download:
      rateLimit: 200Mi
      downloadGRPC:
        security:
          insecure: true
        unixListen:
          socket: /tmp/dfdamon.sock
      peerGRPC:
        security:
          insecure: true
        tcpListen:
          listen: 0.0.0.0
          port: 65000
    upload:
      rateLimit: 100Mi
      security:
        insecure: true
      tcpListen:
        listen: 0.0.0.0
        port: 65002
    storage:
      taskExpireTime: 3m0s
      strategy: io.d7y.storage.v2.simple
      multiplex: true
    proxy:
      defaultFilter: "Expires&Signature"
      security:
        insecure: true
      tcpListen:
        namespace: /run/dragonfly/net
        listen: 0.0.0.0
        # if you want to change port, please update hostPort in $.Values.dfdaemon.hostPort
        # port in configmap is generated from $.Values.dfdaemon.hostPort
        # port: 65001
      registryMirror:
        dynamic: true
        url: https://index.docker.io
      proxies:
        - regx: blobs/sha256.*

manager:
  name: manager
  nameOverride: ""
  fullnameOverride: ""
  replicas: 3
  image: dragonflyoss/manager
  tag: v0.1.0
  pullPolicy: IfNotPresent
  resources:
    requests:
      cpu: "0"
      memory: "0"
    limits:
      cpu: "2"
      memory: "4Gi"
  priorityClassName: ""
  nodeSelector: {}
  terminationGracePeriodSeconds:
  tolerations: []
  podAnnotations: {}
  podLabels: {}
  serviceAnnotations: {}
  statefulsetAnnotations: {}
  restPort: 8080
  grpcPort: 65003

mysql:
  enable: true
  migrate: true
  auth:
    rootPassword: dragonfly-root
    username: dragonfly
    password: dragonfly
    database: manager
  primary:
    service:
      port: 3306

redis:
  enable: true
  password: dragonfly
  service:
    port: 6379
